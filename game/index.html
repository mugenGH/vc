<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Asylum of Echoes</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Nosifer&family=Butcherman&display=swap');
    
    :root {
      --dark-bg: #0a0a0f;
      --purple: #6b2d5c;
      --gold: #d4af37;
      --blood-red: #8b0000;
      --parchment: #f4e8d0;
      --green: #2d5a2d;
      --neon-blue: #00f3ff;
      --neon-purple: #bf00ff;
      --shadow-deep: rgba(0,0,0,0.8);
    }

    * { 
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: radial-gradient(circle at 30% 20%, #1a0d1a, #0a0a0f),
                  linear-gradient(45deg, #0f0f1a 0%, #1a0a1a 50%, #0a0f0a 100%);
      color: var(--parchment);
      font-family: "Butcherman", serif;
      min-height: 100vh;
      overflow-x: hidden;
      animation: bodyPulse 10s ease-in-out infinite;
    }

    @keyframes bodyPulse {
      0%, 100% { background-size: 100% 100%; }
      50% { background-size: 110% 110%; }
    }

    #app {
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, 
        rgba(10,10,15,0.95) 0%, 
        rgba(20,10,20,0.9) 40%,
        rgba(10,20,10,0.9) 70%,
        rgba(15,5,15,0.95) 100%);
      backdrop-filter: blur(2px);
      display: grid;
      grid-template-areas: 
        "header header header"
        "sidebar main dialogue"
        "choices choices choices"
        "inventory inventory inventory";
      grid-template-rows: auto 1fr auto auto;
      grid-template-columns: 250px 1fr 300px;
      gap: 8px;
      padding: 8px;
      box-shadow: inset 0 0 50px rgba(139,0,0,0.3);
    }

    header {
      grid-area: header;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 24px;
      background: linear-gradient(90deg, 
        rgba(139,0,0,0.8) 0%,
        rgba(107,45,92,0.6) 30%,
        rgba(0,0,0,0.9) 70%,
        rgba(139,0,0,0.8) 100%);
      border: 2px solid var(--blood-red);
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(139,0,0,0.5),
                  inset 0 0 20px rgba(0,0,0,0.8);
      position: relative;
      overflow: hidden;
    }

    header::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      animation: headerSweep 8s linear infinite;
    }

    @keyframes headerSweep {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    header h1 {
      font-family: "Nosifer", serif;
      font-size: clamp(1.8rem, 3vw, 2.5rem);
      color: var(--gold);
      text-shadow: 
        0 0 10px var(--blood-red),
        0 0 20px var(--blood-red),
        2px 2px 4px rgba(0,0,0,0.8);
      letter-spacing: 3px;
      animation: titlePulse 3s ease-in-out infinite;
    }

    @keyframes titlePulse {
      0%, 100% { transform: scale(1); text-shadow: 0 0 10px var(--blood-red); }
      50% { transform: scale(1.05); text-shadow: 0 0 20px var(--blood-red), 0 0 30px var(--neon-purple); }
    }

    .meta {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
      font-size: 0.9rem;
      color: var(--neon-blue);
      text-shadow: 0 0 8px currentColor;
    }

    .meta span { 
      display: block;
      padding: 6px 12px;
      background: rgba(0,243,255,0.1);
      border: 1px solid rgba(0,243,255,0.3);
      border-radius: 20px;
      backdrop-filter: blur(4px);
      transition: all 0.3s ease;
    }

    .meta span:hover {
      background: rgba(0,243,255,0.2);
      box-shadow: 0 0 15px rgba(0,243,255,0.4);
    }

    #sidebar {
      grid-area: sidebar;
      background: linear-gradient(180deg, 
        rgba(20,10,30,0.9) 0%,
        rgba(30,15,40,0.8) 100%);
      border: 2px solid rgba(107,45,92,0.6);
      border-radius: 12px;
      padding: 16px;
      box-shadow: inset 0 0 20px rgba(0,0,0,0.7);
    }

    #main-scene {
      grid-area: main;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    #scene {
      background: linear-gradient(135deg, 
        rgba(10,10,15,0.95) 0%,
        rgba(25,15,35,0.9) 100%);
      border: 2px solid rgba(139,0,0,0.6);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 
        0 0 30px rgba(139,0,0,0.4),
        inset 0 0 30px rgba(0,0,0,0.8);
      position: relative;
      overflow: hidden;
      min-height: 400px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    #scene::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 30%, rgba(139,0,0,0.1), transparent 50%),
        linear-gradient(45deg, rgba(0,0,0,0.3) 0%, transparent 50%);
      pointer-events: none;
      animation: sceneAmbient 6s ease-in-out infinite;
    }

    @keyframes sceneAmbient {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.7; }
    }

    #background {
      position: relative;
      height: 200px;
      border-radius: 12px;
      border: 2px solid rgba(212,175,55,0.4);
      overflow: hidden;
      background: linear-gradient(135deg, #111, #222);
      box-shadow: 0 0 20px rgba(0,0,0,0.8);
    }

    #background img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      filter: saturate(0.7) contrast(1.2) brightness(0.6) sepia(0.3);
      transition: all 0.5s ease;
    }

    #background:hover img {
      filter: saturate(1) contrast(1.3) brightness(0.8) sepia(0.2);
      transform: scale(1.02);
    }

    #scene-text {
      font-size: clamp(1rem, 1.4vw, 1.15rem);
      line-height: 1.7;
      min-height: 120px;
      white-space: pre-wrap;
      padding: 16px;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      border-left: 3px solid var(--gold);
      text-shadow: 0 1px 2px rgba(0,0,0,0.4);
      transition: all 0.3s ease;
    }

    #presence {
      display: flex;
      gap: 10px;
      font-size: 0.9rem;
      color: #c3b99e;
    }

    .presence-tag {
      padding: 4px 10px;
      border: 1px solid #2a2730;
      border-radius: 999px;
      background: rgba(20,20,30,0.7);
    }

    #dialogue {
      grid-area: dialogue;
      background: linear-gradient(135deg, 
        rgba(15,12,18,0.95) 0%,
        rgba(30,20,35,0.9) 100%);
      border: 2px solid rgba(212,175,55,0.6);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 
        0 0 25px rgba(212,175,55,0.3),
        inset 0 0 25px rgba(0,0,0,0.8);
      animation: dialogueSlide 0.6s ease-out;
      position: relative;
      overflow: hidden;
    }

    #dialogue::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, 
        transparent, var(--gold), transparent);
      animation: dialogueGlow 2s ease-in-out infinite;
    }

    @keyframes dialogueGlow {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    #dialogue h3 {
      font-family: "Creepster", serif;
      font-size: 1.4rem;
      color: var(--gold);
      text-shadow: 
        0 0 10px var(--gold),
        2px 2px 4px rgba(0,0,0,0.8);
      margin-bottom: 12px;
      border-bottom: 2px solid rgba(212,175,55,0.4);
      padding-bottom: 8px;
    }

    #dialogue p {
      font-family: "Butcherman", serif;
      font-size: 1.1rem;
      line-height: 1.6;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
      color: var(--parchment);
    }

    #choices {
      grid-area: choices;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 12px;
      padding: 16px;
      background: linear-gradient(135deg, 
        rgba(10,10,15,0.9) 0%,
        rgba(20,15,25,0.8) 100%);
      border: 2px solid rgba(107,45,92,0.4);
      border-radius: 12px;
      box-shadow: inset 0 0 20px rgba(0,0,0,0.6);
    }

    .choice-btn {
      background: linear-gradient(135deg, 
        rgba(30,20,40,0.9) 0%,
        rgba(40,25,50,0.8) 100%);
      color: var(--parchment);
      border: 2px solid rgba(139,0,0,0.6);
      padding: 16px 20px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 1rem;
      font-family: "Butcherman", serif;
      text-align: left;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    .choice-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent, rgba(139,0,0,0.3), transparent);
      transition: left 0.5s ease;
    }

    .choice-btn:hover {
      transform: translateY(-2px);
      border-color: var(--gold);
      box-shadow: 
        0 6px 25px rgba(139,0,0,0.4),
        0 0 20px rgba(212,175,55,0.3);
      text-shadow: 0 0 8px var(--gold);
    }

    .choice-btn:hover::before {
      left: 100%;
    }

    .choice-btn:active {
      transform: translateY(0px);
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }

    /* Menu button styling */
    #new-game, #continue-game, #toggle-audio {
      background: linear-gradient(135deg, 
        rgba(30,20,40,0.9) 0%,
        rgba(40,25,50,0.8) 100%);
      color: var(--parchment);
      border: 2px solid rgba(139,0,0,0.6);
      padding: 16px 24px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 1.1rem;
      font-family: "Butcherman", serif;
      text-align: center;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      min-width: 200px;
      margin: 8px 0;
    }

    #new-game::before, #continue-game::before, #toggle-audio::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent, rgba(139,0,0,0.3), transparent);
      transition: left 0.5s ease;
    }

    #new-game:hover, #continue-game:hover, #toggle-audio:hover {
      transform: translateY(-2px);
      border-color: var(--gold);
      box-shadow: 
        0 6px 25px rgba(139,0,0,0.4),
        0 0 20px rgba(212,175,55,0.3);
      text-shadow: 0 0 8px var(--gold);
    }

    #new-game:hover::before, #continue-game:hover::before, #toggle-audio:hover::before {
      left: 100%;
    }

    #new-game:active, #continue-game:active, #toggle-audio:active {
      transform: translateY(0px);
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }

    .menu-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 24px;
      background: linear-gradient(135deg, 
        rgba(10,10,15,0.9) 0%,
        rgba(20,15,25,0.8) 100%);
      border: 2px solid rgba(107,45,92,0.4);
      border-radius: 12px;
      box-shadow: inset 0 0 20px rgba(0,0,0,0.6);
      margin: 20px 0;
    }

    #inventory-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      max-height: 200px;
      overflow-y: auto;
    }

    .item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      background: linear-gradient(135deg, rgba(0,0,0,0.7), rgba(139,0,0,0.3));
      border: 1px solid var(--gold);
      border-radius: 8px;
      transition: all 0.3s ease;
    }

    .item:hover {
      box-shadow: 0 0 15px rgba(212,175,55,0.4);
      transform: translateX(4px);
    }

    .item-icon {
      font-size: 1.2rem;
      filter: sepia(1) hue-rotate(25deg);
    }

    .item-name {
      color: var(--parchment);
      font-size: 0.9rem;
      font-family: "Butcherman", serif;
    }

    .puzzle-container {
      background: linear-gradient(135deg, 
        rgba(139,0,0,0.2) 0%,
        rgba(30,10,40,0.8) 100%);
      border: 3px solid var(--gold);
      border-radius: 16px;
      padding: 24px;
      margin: 16px 0;
      box-shadow: 
        0 0 30px rgba(212,175,55,0.4),
        inset 0 0 30px rgba(0,0,0,0.7);
      animation: puzzleGlow 3s ease-in-out infinite;
      max-width: 80vw;
      max-height: 80vh;
      overflow-y: auto;
    }

    @keyframes puzzleGlow {
      0%, 100% { box-shadow: 0 0 30px rgba(212,175,55,0.4), inset 0 0 30px rgba(0,0,0,0.7); }
      50% { box-shadow: 0 0 50px rgba(212,175,55,0.6), inset 0 0 30px rgba(0,0,0,0.7); }
    }

    .puzzle-title {
      font-family: "Creepster", serif;
      font-size: 1.6rem;
      color: var(--gold);
      text-align: center;
      margin-bottom: 16px;
      text-shadow: 0 0 15px var(--gold);
    }

    .puzzle-input {
      width: 100%;
      padding: 16px;
      font-size: 1.2rem;
      background: rgba(0,0,0,0.8);
      border: 2px solid var(--blood-red);
      border-radius: 8px;
      color: var(--parchment);
      text-align: center;
      font-family: "Butcherman", serif;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .puzzle-input:focus {
      outline: none;
      border-color: var(--gold);
      box-shadow: 0 0 20px rgba(212,175,55,0.5);
    }

    .puzzle-hints {
      margin: 16px 0;
      padding: 12px;
      background: rgba(0,0,0,0.6);
      border-radius: 8px;
      font-size: 0.9rem;
      color: var(--neon-blue);
    }

    .hint-btn {
      background: linear-gradient(135deg, rgba(0,243,255,0.2), rgba(191,0,255,0.2));
      border: 2px solid var(--neon-blue);
      color: var(--neon-blue);
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      margin: 4px;
      font-size: 0.8rem;
      transition: all 0.3s ease;
    }

    .hint-btn:hover {
      background: linear-gradient(135deg, rgba(0,243,255,0.4), rgba(191,0,255,0.4));
      box-shadow: 0 0 15px var(--neon-blue);
    }

    #puzzle-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .item-btn {
      background: linear-gradient(135deg, rgba(139,0,0,0.3), rgba(0,0,0,0.7));
      border: 2px solid var(--gold);
      color: var(--parchment);
      padding: 12px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-family: "Butcherman", serif;
      transition: all 0.3s ease;
    }

    .item-btn:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(139,0,0,0.5), rgba(212,175,55,0.2));
      box-shadow: 0 0 15px rgba(212,175,55,0.4);
    }

    .item-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    @keyframes resultFade {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.1); }
    }

    .save-slot {
      border: 1px solid #26202f;
      border-radius: 10px;
      padding: 10px 12px;
      background: rgba(20,18,24,0.7);
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
      font-size: 0.85rem;
    }

    .save-slot button {
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #3a2f46;
      background: rgba(30,26,36,0.9);
      color: var(--parchment);
      cursor: pointer;
    }

    #overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: transparent;
      z-index: 5;
    }

    .flicker {
      animation: flicker 0.8s ease;
    }

    .glitch {
      animation: glitch 0.6s linear;
    }

    .blood {
      animation: blood 1.4s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-10px); }
      to { opacity: 1; transform: translateX(0); }
    }

    @keyframes flicker {
      0%, 100% { background: transparent; }
      20% { background: rgba(255,255,255,0.05); }
      40% { background: rgba(255,255,255,0.12); }
      60% { background: rgba(0,0,0,0.4); }
      80% { background: rgba(255,255,255,0.04); }
    }

    @keyframes glitch {
      0% { clip-path: inset(0 0 0 0); filter: hue-rotate(0deg); }
      20% { clip-path: inset(5% 0 15% 0); filter: hue-rotate(40deg); }
      40% { clip-path: inset(15% 0 10% 0); }
      60% { clip-path: inset(0 0 20% 0); filter: hue-rotate(-10deg); }
      80% { clip-path: inset(10% 0 5% 0); }
      100% { clip-path: inset(0 0 0 0); filter: hue-rotate(0deg); }
    }

    @keyframes blood {
      0% { background: transparent; }
      20% { background: linear-gradient(180deg, rgba(139,0,0,0.45), transparent); }
      100% { background: transparent; }
    }

    @keyframes dialogueSlide {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .puzzle-container {
      background: linear-gradient(135deg, 
        rgba(139,0,0,0.2) 0%,
        rgba(30,10,40,0.8) 100%);
      border: 3px solid var(--gold);
      border-radius: 16px;
      padding: 24px;
      margin: 16px 0;
      box-shadow: 
        0 0 30px rgba(212,175,55,0.4),
        inset 0 0 30px rgba(0,0,0,0.7);
      animation: puzzleGlow 3s ease-in-out infinite;
    }

    @keyframes puzzleGlow {
      0%, 100% { box-shadow: 0 0 30px rgba(212,175,55,0.4), inset 0 0 30px rgba(0,0,0,0.7); }
      50% { box-shadow: 0 0 50px rgba(212,175,55,0.6), inset 0 0 30px rgba(0,0,0,0.7); }
    }

    .puzzle-title {
      font-family: "Creepster", serif;
      font-size: 1.6rem;
      color: var(--gold);
      text-align: center;
      margin-bottom: 16px;
      text-shadow: 0 0 15px var(--gold);
    }

    .puzzle-input {
      width: 100%;
      padding: 16px;
      font-size: 1.2rem;
      background: rgba(0,0,0,0.8);
      border: 2px solid var(--blood-red);
      border-radius: 8px;
      color: var(--parchment);
      text-align: center;
      font-family: "Butcherman", serif;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .puzzle-input:focus {
      outline: none;
      border-color: var(--gold);
      box-shadow: 0 0 20px rgba(212,175,55,0.5);
    }

    .puzzle-hints {
      margin: 16px 0;
      padding: 12px;
      background: rgba(0,0,0,0.6);
      border-radius: 8px;
      font-size: 0.9rem;
      color: var(--neon-blue);
    }

    .hint-btn {
      background: linear-gradient(135deg, rgba(0,243,255,0.2), rgba(191,0,255,0.2));
      border: 2px solid var(--neon-blue);
      color: var(--neon-blue);
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      margin: 4px;
      font-size: 0.8rem;
      transition: all 0.3s ease;
    }

    .hint-btn:hover {
      background: linear-gradient(135deg, rgba(0,243,255,0.4), rgba(191,0,255,0.4));
      box-shadow: 0 0 15px var(--neon-blue);
    }

    @media (max-width: 820px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }

      .meta { align-items: flex-start; }
    }
  </style>
</head>
<body>
  <div id="overlay"></div>
  <main id="app">
    <header>
      <h1>ASYLUM OF ECHOES</h1>
      <div class="meta">
        <span id="room-name">Main Menu</span>
        <span id="chapter-info">Chapter 0</span>
        <span id="clue-info">Clues: 0</span>
        <span id="fear-info">Fear: 0</span>
      </div>
    </header>

    <aside id="sidebar">
      <section id="inventory" hidden>
        <h3>Inventory</h3>
        <div id="inventory-grid"></div>
      </section>
      
      <section id="character-status" hidden>
        <h3>Companions</h3>
        <div id="npc-status"></div>
      </section>
    </aside>

    <section id="main-scene">
      <div id="menu">
        <div class="menu-content">
          <p>Enter the abandoned asylum and follow the echoes of the missing. The building remembers.</p>
          <div class="menu-actions">
            <button id="new-game">Start New Game</button>
            <button id="continue-game">Continue</button>
            <button id="toggle-audio">Audio: On</button>
          </div>
          <div id="save-slots"></div>
        </div>
      </div>

      <div id="scene" hidden>
        <div id="background"><img id="background-img" alt="room background" /></div>
        <div id="scene-text"></div>
        <div id="presence"></div>
      </div>
    </section>

    <section id="dialogue" hidden>
      <h3 id="dialogue-name"></h3>
      <p id="dialogue-text"></p>
    </section>

    <section id="choices" hidden></section>
    
    <div id="puzzle-modal" hidden>
      <div class="puzzle-container">
        <div class="puzzle-title" id="puzzle-title"></div>
        <div class="puzzle-content" id="puzzle-content"></div>
        <div class="puzzle-hints" id="puzzle-hints"></div>
        <div class="puzzle-controls" id="puzzle-controls"></div>
      </div>
    </div>
  </main>

  <script>
    // Global Error Handler for Runtime Errors outside Modules
    window.addEventListener("error", function(event) {
      console.error("Global Error:", event.error);
      const errorBox = document.createElement("div");
      errorBox.style.cssText = "position:fixed; top:0; left:0; right:0; padding:20px; background:#800; color:#fff; z-index:9999; font-family:monospace;";
      errorBox.innerHTML = "<strong>Runtime Error:</strong> " + event.message + "<br><small>" + event.filename + ":" + event.lineno + "</small>";
      document.body.appendChild(errorBox);
    });
  </script>
  <script type="module">
    // ---------- Core State ----------
    const gameState = {
          playerName: "You",
          chapter: 1,
          currentRoom: "entrance",
          inventory: [],
          roomsVisited: {},
          relationships: {
            dwarf: { trust: 0, alive: true, met: false },
            troll: { trust: 0, alive: true, met: false }
          },
          flags: {
            met_dwarf_and_troll: false,
            agreed_to_help: false,
            examined_portrait: false,
            records_found: false,
            examined_cabinet: false,
            heard_wall_sounds: false,
            anaconda_hinted: false,
            anaconda_weakening: false,
            troll_sacrifice: false,
            first_door_code_solved: false,
            learned_truth: false,
            cabinet_code_solved: false,
            cell_puzzle_solved: false,
            white_skeleton_seen: false,
            chose_to_stay: false
          },
          fear: 0,
          audioOn: true,
          lastDialogue: null,
          lastNarration: "",
          pendingEnding: null,
          save(slot) {
            const data = this.serialize();
            localStorage.setItem(slot, JSON.stringify(data));
          },
          load(slot) {
            const raw = localStorage.getItem(slot);
            if (!raw) return false;
            const data = JSON.parse(raw);
            this.apply(data);
            return true;
          },
          autoSave() {
            this.save("autoSave");
          },
          serialize() {
            return {
              playerName: this.playerName,
              chapter: this.chapter,
              currentRoom: this.currentRoom,
              inventory: [...this.inventory],
              relationships: JSON.parse(JSON.stringify(this.relationships)),
              flags: JSON.parse(JSON.stringify(this.flags)),
              roomsVisited: JSON.parse(JSON.stringify(this.roomsVisited)),
              fear: this.fear,
              audioOn: this.audioOn,
              lastDialogue: this.lastDialogue,
              lastNarration: this.lastNarration,
              timestamp: Date.now()
            };
          },
          apply(data) {
            this.playerName = data.playerName ?? "You";
            this.chapter = data.chapter ?? 1;
            this.currentRoom = data.currentRoom ?? "entrance";
            this.inventory = data.inventory ?? [];
            this.relationships = data.relationships ?? this.relationships;
            this.flags = data.flags ?? this.flags;
            this.roomsVisited = data.roomsVisited ?? {};
            this.fear = data.fear ?? 0;
            this.audioOn = data.audioOn ?? true;
            this.lastDialogue = data.lastDialogue ?? null;
            this.lastNarration = data.lastNarration ?? "";
            this.pendingEnding = null;
          },
          adjustTrust(npc, delta) {
            const target = this.relationships[npc];
            if (!target) return;
            target.trust = Math.max(-100, Math.min(100, target.trust + delta));
          },
          addItem(item) {
            if (this.inventory.includes(item)) return false;
            if (this.inventory.length >= 8) return false;
            this.inventory.push(item);
            return true;
          },
          removeItem(item) {
            this.inventory = this.inventory.filter((i) => i !== item);
          }
        };

        // ---------- Data: NPCs ----------
        const NPCs = {
          dwarf: {
            name: "Pip",
            description: "Small, nervous, intelligent.",
            dialogue: {
              first_meet: [
                "Please... you can hear us, right? The doors don't open anymore.",
                "I'm Pip. Don't trust the walls. They listen.",
                "We've been trapped here... how long now? Time moves differently in this place."
              ],
              agreed_to_help: [
                "Thank you. I know it's foolish to hope, but hope is a habit.",
                "Maybe together we can find what the shadows are hiding."
              ],
              wall_sounds: [
                "That scraping... it's learned our steps. It waits.",
                "Do you hear that? The walls are breathing again."
              ],
              troll_death: [
                "He stayed behind... he told me to go. I can't forget that.",
                "His last words were about the door... always about the door."
              ],
              general: [
                "This place feeds on fear. Try not to give it what it wants.",
                "The building remembers everyone who enters. But not everyone who leaves.",
                "Stay close to me. The shadows move when you're alone."
              ],
              trust_check: {
                high: "You're steady. I think we can do this together.",
                mid: "Stay close. The building changes when it likes you.",
                low: "I don't know who you are, but I know what this place does to people."
              }
            }
          },
          troll: {
            name: "The Troll",
            description: "Large, gentle, speaks in short truths.",
            dialogue: {
              first_meet: [
                "Welcome. I am here. We will leave. Together.",
                "The Dwarf is afraid. I am not afraid. But I am not brave.",
                "This place knows us. We know this place. Balance."
              ],
              comfort: [
                "Do you hurt? This place hurts. But we can leave.",
                "Pain is temporary. Fear is choice."
              ],
              sacrifice: [
                "I will be right behind you. Keep the Dwarf safe. Tell him... the door is open.",
                "Some doors need weight to hold them. I am weight."
              ],
              general: [
                "Building speaks. We listen. We understand.",
                "Small one worries. Big one protects. You... you choose.",
                "Stone remembers. Metal forgets. Choose wisely."
              ],
              trust_check: {
                high: "We walk with you. Path is clearer.",
                mid: "We walk. Step by step.",
                low: "Walking alone. Dangerous."
              }
            }
          }
        };

        // ---------- Data: Puzzles ----------
        const PUZZLES = {
          first_door_code: {
            id: "first_door_code",
            solution: "1947",
            type: "sequence",
            clue: "The director's portrait lists the birth year 1947.",
            hints: [
              "Look for numbers in the director's portrait...",
              "Birth years are often significant...",
              "Four digits, starting with 19..."
            ],
            consequence(state) {
              state.flags.first_door_code_solved = true;
              state.addItem("Records Folder (Subject 47)");
              state.flags.records_found = true;
              state.flags.learned_truth = true;
              return "The drawer clicks open with a mechanical whir. Inside: a folder labeled SUBJECT 47, bound with dark red string. The pages feel warm to the touch.";
            }
          },
          cabinet_code: {
            id: "cabinet_code",
            solution: "739",
            type: "combination",
            clue: "Treatment chart numbers 7-3-9 are circled in fading ink.",
            hints: [
              "The treatment chart has specific numbers marked...",
              "Three digits, in sequence...",
              "Fear, Compliance, Isolation - count the letters?"
            ],
            consequence(state) {
              state.flags.cabinet_code_solved = true;
              state.addItem("Patient Journal");
              state.addItem("Medicine Vials (Red & Blue)");
              state.addItem("Strange Key (Basement)");
              return "The cabinet springs open with a hiss of stale air. Brittle journals crumble at your touch, and two vials - one blood-red, one ice-blue - roll forward. A strange key clatters to the floor.";
            }
          },
          cell_puzzle: {
            id: "cell_puzzle",
            solution: "CANNOT",
            type: "word",
            clue: "Scratches repeat: I AM HERE. I CANNOT LEAVE. IT CANNOT LEAVE. WE ARE THE SAME.",
            hints: [
              "The scratches form a pattern, a desperate message...",
              "What word appears most often in the scratches?",
              "Focus on what binds both the prisoner and the presence..."
            ],
            consequence(state) {
              state.flags.cell_puzzle_solved = true;
              state.chapter = 3;
              state.flags.white_skeleton_seen = true;
              return "The word CANNOT echoes in your mind. The scratches glow briefly, and a hidden door in the wall grinds open, revealing stairs descending into darkness. A white skeleton sits by the entrance, as if waiting.";
            }
          },
          basement_ritual: {
            id: "basement_ritual",
            solution: ["RED_VIAL", "STRANGE_KEY", "PATIENT_JOURNAL"],
            type: "sequence_items",
            clue: "Three elements must be combined in the correct order to weaken the presence.",
            hints: [
              "The ritual requires blood, knowledge, and a way forward...",
              "Red comes first - the offering of life force...",
              "Then wisdom from the written word...",
              "Finally, the key to unlock what was sealed..."
            ],
            consequence(state) {
              state.flags.anaconda_weakening = true;
              state.flags.ritual_completed = true;
              return "As you complete the ritual, the air grows thick. The scraping sound falters, becoming weak and distant. The presence that haunted these halls begins to fade, but something else stirs in the depths...";
            }
          },
          final_choice: {
            id: "final_choice",
            solution: "UNDERSTANDING",
            type: "philosophical",
            clue: "To escape, you must understand what you truly are in this place.",
            hints: [
              "Are you the savior, the prisoner, or something else?",
              "What connects you to Subject 47?",
              "Sometimes the greatest truth is accepting what you cannot change..."
            ],
            consequence(state) {
              state.flags.final_understanding = true;
              return "Understanding floods through you. You are not here to save or be saved. You are here to witness, to remember, to become part of the story that the building tells. The choice is not whether to leave, but how to belong.";
            }
          }
        };

        // ---------- Visual Effects ----------
        const PsychologicalEffects = {
          applyFlicker(overlay) {
            this.resetEffects(overlay);
            overlay.classList.add("flicker");
          },
          applyGlitch(overlay) {
            this.resetEffects(overlay);
            overlay.classList.add("glitch");
          },
          applyBlood(overlay) {
            this.resetEffects(overlay);
            overlay.classList.add("blood");
          },
          resetEffects(overlay) {
            overlay.classList.remove("flicker", "glitch", "blood");
            void overlay.offsetWidth; // Force reflow
          }
        };

        // ---------- Audio ----------
        class SoundManager {
          constructor(state) {
            this.state = state;
            this.ctx = null;
            this.background = null;
            this.currentBg = null;
          }

          ensureContext() {
            if (!this.ctx) {
              this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
          }

          playEffect(type) {
            if (!this.state.audioOn) return;
            this.ensureContext();
            const ctx = this.ctx;
            const now = ctx.currentTime;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            const filter = ctx.createBiquadFilter();
            osc.connect(filter).connect(gain).connect(ctx.destination);
            gain.gain.setValueAtTime(0.0001, now);

            if (type === "whisper") {
              osc.type = "sine";
              osc.frequency.setValueAtTime(150, now);
              gain.gain.exponentialRampToValueAtTime(0.08, now + 0.2);
              gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.5);
              osc.start();
              osc.stop(now + 1.6);
            } else if (type === "breathing") {
              osc.type = "sine";
              osc.frequency.setValueAtTime(120, now);
              osc.frequency.exponentialRampToValueAtTime(100, now + 1.2);
              gain.gain.exponentialRampToValueAtTime(0.1, now + 0.3);
              gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.6);
              osc.start();
              osc.stop(now + 1.7);
            } else if (type === "door") {
              osc.type = "sawtooth";
              osc.frequency.setValueAtTime(150, now);
              osc.frequency.exponentialRampToValueAtTime(80, now + 0.8);
              gain.gain.exponentialRampToValueAtTime(0.12, now + 0.1);
              gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.8);
              osc.start();
              osc.stop(now + 0.85);
            } else if (type === "heartbeat") {
              osc.type = "sine";
              osc.frequency.setValueAtTime(60, now);
              gain.gain.exponentialRampToValueAtTime(0.18, now + 0.08);
              gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.3);
              osc.start();
              osc.stop(now + 0.31);
            } else if (type === "scare") {
              osc.type = "square";
              osc.frequency.setValueAtTime(300, now);
              gain.gain.exponentialRampToValueAtTime(0.2, now + 0.05);
              gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
              osc.start();
              osc.stop(now + 0.45);
            } else if (type === "scrape") {
              osc.type = "triangle";
              osc.frequency.setValueAtTime(200, now);
              filter.type = "highpass";
              filter.frequency.setValueAtTime(400, now);
              gain.gain.exponentialRampToValueAtTime(0.12, now + 0.1);
              gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.8);
              osc.start();
              osc.stop(now + 0.9);
            }
          }

          playBackground(file) {
            if (!this.state.audioOn) return;
            if (this.background && this.currentBg === file) return; // Don't restart same track
            
            if (this.background) {
              this.background.pause();
            }
            this.background = new Audio(file);
            this.background.loop = true;
            this.background.volume = 0.4;
            this.background.play().catch(() => {});
            this.currentBg = file;
          }

          playDialogue(file) {
            if (!this.state.audioOn) return;
            const audio = new Audio(file);
            audio.volume = 0.3;
            audio.play().catch(() => {});
            setTimeout(() => audio.pause(), 2000);
          }
        }

        // ---------- Data: Rooms ----------
        const ROOMS = {
          entrance: {
            id: "entrance",
            name: "Entrance Corridor",
            background: "assets/images/entrance.jpg",
            firstVisit: "Iron gates drip with cold rust. Dust floats through thin light, touching linoleum with the softness of ash. The corridor smells of old bleach and something damp beneath it.",
            revisit: "The entrance corridor waits with the same iron patience. The gates refuse every memory of a key.",
            npcPresence: ["dwarf", "troll"],
            choices(state) {
              if (!state.flags.met_dwarf_and_troll) {
                return [
                  { text: "Listen to what they have to say", action: "entrance_listen" },
                  { text: "Ask them who they are", action: "entrance_ask" },
                  { text: "Demand to know where the exit is", action: "entrance_demand" }
                ];
              }
              return [
                { text: "Move forward", action: "go_hallway" },
                { text: "Talk to the Dwarf again", action: "talk_dwarf" },
                { text: "Try the gates", action: "try_gates" }
              ];
            }
          },
          hallway_main: {
            id: "hallway_main",
            name: "Hallway Main - Ward A",
            background: "assets/images/hall.jpg",
            firstVisit: "Flickering fluorescent tubes hum above. Behind wire mesh windows, doors are locked from both sides. The hallway stretches until it forgets itself.",
            revisit: "The lights stutter. The wire windows watch back.",
            npcPresence: ["dwarf", "troll"],
            choices(state) {
              return [
                { text: "Examine the doors", action: "hall_examine" },
                { text: "Head toward the administrative wing", action: "go_office" },
                { text: "Go to the medical ward", action: "go_medical" },
                { text: "Listen to the silence", action: "hall_listen" },
                state.relationships.troll.alive ? { text: "Ask the Troll a question", action: "talk_troll" } : null
              ].filter(Boolean);
            }
          },
          office: {
            id: "office",
            name: "Administrative Office",
            background: "assets/images/office.jpg",
            firstVisit: "Desks hunch beneath brittle paperwork. The director's portrait watches the room, eyes flecked with varnish. Empty files speak in paper dust.",
            revisit: "The office smells of old ink and stale decisions.",
            npcPresence: ["dwarf"],
            choices(state) {
              return [
                { text: "Search the files more thoroughly", action: "office_search" },
                { text: "Examine the portrait more closely", action: "office_portrait" },
                { text: "Take the note", action: "office_note" },
                state.flags.examined_portrait && !state.flags.first_door_code_solved
                  ? { text: "Try the locked desk drawer code...", action: "office_puzzle" }
                  : null,
                state.flags.first_door_code_solved
                  ? { text: "Examine the opened drawer contents", action: "office_drawer" }
                  : null,
                { text: "Leave the office", action: "go_hallway" }
              ].filter(Boolean);
            }
          },
          medical: {
            id: "medical",
            name: "Medical Ward - Treatment Room",
            background: "assets/images/medical.jpg",
            firstVisit: "Beds with restraints line the walls. Unmarked bottles cling to a cabinet. A chart on the wall lists: FEAR, COMPLIANCE, ISOLATION, ACCEPTANCE, DISSOLUTION.",
            revisit: "The restraints rattle as the air moves. The chart is unchanged.",
            npcPresence: ["dwarf", "troll"],
            choices(state) {
              return [
                { text: "Examine the medicine cabinet", action: "medical_cabinet" },
                { text: "Study the treatment chart", action: "medical_chart" },
                { text: "Approach the secured ward door", action: "go_cell" },
                { text: "Leave the ward", action: "go_hallway" }
              ];
            }
          },
          cell: {
            id: "cell",
            name: "Secured Ward",
            background: "assets/images/cell.jpg",
            firstVisit: "A single concrete cell. Scratches carve desperate lines: I AM HERE. I CANNOT LEAVE. IT CANNOT LEAVE. WE ARE THE SAME. A stone platform squats in the center.",
            revisit: "The words claw into the wall each time you return.",
            npcPresence: ["dwarf"],
            choices(state) {
              return [
                { text: "Read the scratches more carefully", action: "cell_read" },
                { text: "Search for more clues in the cell", action: "cell_search" },
                { text: "Listen for sounds in the walls", action: "cell_listen" },
                state.flags.cell_puzzle_solved ? { text: "Step into the opened doorway", action: "go_basement" } : null,
                { text: "Leave immediately", action: "go_medical" }
              ].filter(Boolean);
            }
          },
          basement: {
            id: "basement",
            name: "Basement Corridor",
            background: "assets/images/basement.jpg",
            firstVisit: "Steam pipes sweat against the ceiling. Mist drags itself along the floor. A long, slow scraping repeats, patient as breathing.",
            revisit: "The scraping returns, closer, remembering you.",
            npcPresence: ["dwarf", "troll"],
            choices(state) {
              const exitChoices = state.flags.anaconda_weakening
                ? [
                    { text: "Push toward the exit", action: "basement_escape" },
                    { text: "Remain behind", action: "basement_stay" }
                  ]
                : [];
              
              // If troll is alive, show troll-dependent choices
              if (state.relationships.troll.alive) {
                return [
                  { text: "Run forward", action: "basement_run" },
                  { text: "Try to hide", action: "basement_hide" },
                  { text: "Ask what it is", action: "basement_ask" },
                  { text: "Hold your ground", action: "basement_hold" },
                  ...exitChoices
                ];
              }
              // Troll is dead - show post-sacrifice choices
              return [
                { text: "Move through carefully", action: "basement_move" },
                { text: "The sound is different now. Weaker.", action: "basement_weaker" },
                { text: "Listen for the Dwarf", action: "basement_dwarf" },
                ...exitChoices
              ];
            }
          }
        };

        // ---------- Data: Endings ----------
        const ENDINGS = {
          hope: {
            id: "hope",
            name: "HOPE",
            condition(state) {
              return state.flags.learned_truth &&
                state.relationships.dwarf.alive &&
                state.relationships.dwarf.trust > 20 &&
                (state.flags.anaconda_weakening || state.flags.cabinet_code_solved) &&
                !state.flags.troll_sacrifice;
            },
            text: "The gates open. You walk through themâ€”all three of you.\nThe Dwarf, the Troll, and something like safety.\n\n\"We made it,\" the Dwarf whispers.\nThe Troll places a hand on his shoulder. \"We made it.\"\n\nThe building remains behind, hungry and unsatisfied.\nBut that's not your story anymore.\n\nENDING: HOPE"
          },
          truth: {
            id: "truth",
            name: "TRUTH",
            condition(state) {
              return state.flags.learned_truth &&
                state.flags.records_found &&
                (state.relationships.dwarf.alive || state.relationships.troll.alive) &&
                state.relationships.dwarf.trust > 30;
            },
            text: "You understand now. The building was never meant to cure.\nIt was meant to contain.\n\nThe missing person wasn't taken. They were added.\nSubject 47. Anomalous. No further details.\n\nOne will consume the other. You chose which one survived.\n\nENDING: TRUTH"
          },
          sacrifice: {
            id: "sacrifice",
            name: "SACRIFICE",
            condition(state) {
              return state.flags.troll_sacrifice &&
                !state.relationships.troll.alive &&
                state.relationships.dwarf.alive &&
                state.relationships.dwarf.trust > 30; // Reduced from 40
            },
            text: "The Troll held the door. The Troll kept his promise.\nThe door is open.\n\nYou and the Dwarf escape. But the weight of his sacrifice\nwill never leave you.\n\nIn your dreams, you hear his voice:\n\"I am still here.\"\n\nENDING: SACRIFICE"
          },
          acceptance: {
            id: "acceptance",
            name: "ACCEPTANCE",
            condition(state) {
              return state.flags.white_skeleton_seen &&
                state.flags.learned_truth &&
                state.flags.chose_to_stay &&
                state.relationships.dwarf.trust > 30 &&
                state.relationships.troll.trust > 30 &&
                state.flags.anaconda_weakening;
            },
            text: "You realize the truth: Some cannot leave.\nSome don't want to.\n\nThe building needs witnesses. Guardians.\nYou become one with the walls.\n\nThe Dwarf nods. \"I understand.\"\n\nThe gates close. You don't try them anymore.\n\nENDING: ACCEPTANCE"
          },
          alone: {
            id: "alone",
            name: "ALONE",
            condition(state) {
              return !state.relationships.dwarf.alive && !state.relationships.troll.alive;
            },
            text: "You escape. Alone.\n\nThe gates close behind you. You are free.\n\nBut in the silence, you hear scraping.\nAlways scraping.\n\nYou brought something with you.\nOr something brought you.\n\nENDING: ALONE"
          }
        };

        // ---------- UI Wiring ----------
        const ui = {
          menu: document.getElementById("menu"),
          scene: document.getElementById("scene"),
          dialogue: document.getElementById("dialogue"),
          choices: document.getElementById("choices"),
          inventory: document.getElementById("inventory"),
          inventoryGrid: document.getElementById("inventory-grid"),
          roomName: document.getElementById("room-name"),
          chapterInfo: document.getElementById("chapter-info"),
          clueInfo: document.getElementById("clue-info"),
          fearInfo: document.getElementById("fear-info"),
          backgroundImg: document.getElementById("background-img"),
          sceneText: document.getElementById("scene-text"),
          presence: document.getElementById("presence"),
          dialogueName: document.getElementById("dialogue-name"),
          dialogueText: document.getElementById("dialogue-text"),
          newGame: document.getElementById("new-game"),
          continueGame: document.getElementById("continue-game"),
          toggleAudio: document.getElementById("toggle-audio"),
          saveSlots: document.getElementById("save-slots"),
          overlay: document.getElementById("overlay"),
          puzzleModal: document.getElementById("puzzle-modal"),
          npcStatus: document.getElementById("npc-status")
        };

        const sound = new SoundManager(gameState);

        const itemDescriptions = {
          "Handwritten Note": "It doesn't belong in the building. The building doesn't belong to it. One will consume the other. Hope for the second.",
          "Faded Photograph": "A smudged photo of three staff members. The director stands in the middle.",
          "Patient Journal": "Entries devolve from names to numbers. 47 repeats.",
          "Old Keycard (Red Clearance)": "Red clearance. The edge is warm.",
          "Medicine Vials (Red & Blue)": "Two vials. One cold, one warm.",
          "Records Folder (Subject 47)": "A folder bound with hospital string. Missing person: added, not taken.",
          "Lockpick Set": "Pip's lockpicks, made from wire and stubbornness."
        };

        function switchRoom(roomId) {
          // Save current room state
          if (gameState.currentRoom) {
            const currentRoom = ROOMS[gameState.currentRoom];
            if (currentRoom && currentRoom.onExit) currentRoom.onExit(gameState);
          }
          
          gameState.currentRoom = roomId;
          
          // Enter new room
          const newRoom = ROOMS[roomId];
          if (newRoom && newRoom.onEnter) newRoom.onEnter(gameState);
          
          // Update presence intensity based on story progress
          updatePresenceLevel();
          
          setScene(newRoom);
          renderChoices(newRoom);
          renderInventory();
          updateStats();
          
          // Play atmospheric sound for room change
          sound.playEffect('door');
        }
        
        function updatePresenceLevel() {
          const clueCount = Object.keys(gameState.flags).filter(f => gameState.flags[f]).length;
          const intensity = Math.min(clueCount / 10, 1.0);
          
          if (ui.presence) {
            ui.presence.style.opacity = intensity;
            ui.presence.style.fontSize = `${0.8 + intensity * 0.4}rem`;
            
            const messages = [
              "You feel watched...",
              "Something stirs in the shadows...",
              "The air grows heavy with malice...",
              "Ancient eyes track your movement...",
              "The building itself seems alive...",
              "Reality bends around your presence..."
            ];
            
            if (intensity > 0.2) {
              ui.presence.textContent = messages[Math.floor(intensity * messages.length)];
            } else {
              ui.presence.textContent = "";
            }
          }
        }

        function setScene(room) {
          ui.roomName.textContent = room.name;
          ui.chapterInfo.textContent = "Chapter " + gameState.chapter;
          ui.clueInfo.textContent = "Clues: " + countClues();
          ui.backgroundImg.src = room.background;
          
          const visited = gameState.roomsVisited[room.id];
          const text = visited ? room.revisit : room.firstVisit;
          
          // Animate text change
          ui.sceneText.classList.add('text-updating');
          setTimeout(() => {
            ui.sceneText.textContent = text;
            gameState.lastNarration = text;
            ui.sceneText.classList.remove('text-updating');
          }, 150);
          
          gameState.roomsVisited[room.id] = true;
          renderPresence(room);
        }

        function renderPresence(room) {
          ui.presence.innerHTML = "";
          room.npcPresence.forEach((npcKey) => {
            const npc = gameState.relationships[npcKey];
            // Don't show dead NPCs
            if (!npc || !npc.alive || !npc.met) return;
            const tag = document.createElement("span");
            tag.className = "presence-tag";
            tag.textContent = NPCs[npcKey].name;
            ui.presence.appendChild(tag);
          });
          
          // Add isolation message if troll is dead
          if (!gameState.relationships.troll.alive && gameState.flags.troll_isolation) {
            const isolationTag = document.createElement("span");
            isolationTag.className = "presence-tag";
            isolationTag.style.cssText = "background: rgba(139,0,0,0.8); color: var(--parchment);";
            isolationTag.textContent = "Alone";
            ui.presence.appendChild(isolationTag);
          }
        }

        function showDialogue(npcKey, text) {
          const npc = NPCs[npcKey];
          
          // Animate dialogue appearance
          ui.dialogue.hidden = true;
          setTimeout(() => {
            ui.dialogueName.textContent = npc.name;
            ui.dialogueText.textContent = text;
            ui.dialogue.hidden = false;
            gameState.lastDialogue = { npcKey, text };
            
            if (npcKey === "dwarf") sound.playDialogue("assets/audio/dialogue/dwarf.wav");
            if (npcKey === "troll") sound.playDialogue("assets/audio/dialogue/troll.mp3");
          }, 100);
        }

        function clearDialogue() {
          ui.dialogue.hidden = true;
        }

        function renderChoices(room) {
          ui.choices.innerHTML = "";
          const choices = room.choices(gameState);
          choices.forEach((choice, index) => {
            const button = document.createElement("button");
            button.className = "choice-btn";
            button.style.animationDelay = (index * 0.08) + "s";
            button.textContent = "â†’ " + choice.text;
            button.addEventListener("click", () => handleChoice(choice.action));
            ui.choices.appendChild(button);
          });
        }

        function renderInventory() {
          if (!ui.inventoryGrid) {
            console.warn("inventoryGrid element not found");
            return;
          }
          
          ui.inventoryGrid.innerHTML = "";
          gameState.inventory.forEach(item => {
            const itemDiv = document.createElement("div");
            itemDiv.className = "item";
            itemDiv.innerHTML = `
              <div class="item-icon">ðŸ“œ</div>
              <span class="item-name">${item}</span>
            `;
            itemDiv.title = itemDescriptions[item] || item;
            ui.inventoryGrid.appendChild(itemDiv);
          });
          
          // Show/hide inventory panel
          ui.inventory.hidden = gameState.inventory.length === 0;
        }

        function updateStats() {
          ui.roomName.textContent = ROOMS[gameState.currentRoom]?.name || "Unknown Room";
          ui.chapterInfo.textContent = `Chapter ${gameState.chapter}`;
          ui.clueInfo.textContent = `Clues: ${Object.keys(gameState.flags).filter(f => gameState.flags[f]).length}`;
          ui.fearInfo.textContent = `Fear: ${gameState.fear || 0}`;
          
          // Update NPC relationships if npcStatus element exists
          if (ui.npcStatus && gameState.npcs) {
            ui.npcStatus.innerHTML = Object.entries(gameState.npcs)
              .map(([name, data]) => `
                <div class="npc-card" style="background: rgba(0,0,0,0.6); border: 1px solid var(--gold); border-radius: 8px; padding: 8px; margin: 4px 0;">
                  <strong style="color: var(--gold);">${name}</strong><br>
                  <small style="color: var(--neon-blue);">Trust: ${data.trust}/10</small>
                </div>
              `).join('');
              
            // Show character status if NPCs exist
            const characterStatus = document.getElementById('character-status');
            if (characterStatus) {
              characterStatus.hidden = Object.keys(gameState.npcs).length === 0;
            }
          }
        }

        function countClues() {
          let count = 0;
          if (gameState.flags.examined_portrait) count++;
          if (gameState.flags.records_found) count++;
          if (gameState.flags.examined_cabinet) count++;
          if (gameState.flags.heard_wall_sounds) count++;
          if (gameState.flags.anaconda_hinted) count++;
          return count;
        }

        function hideAllScreens() {
          ui.menu.hidden = true;
          ui.scene.hidden = true;
          ui.dialogue.hidden = true;
          ui.choices.hidden = true;
          ui.inventory.hidden = true;
          if (ui.puzzleModal) ui.puzzleModal.hidden = true;
          const sidebar = document.getElementById('sidebar');
          if (sidebar) {
            sidebar.querySelectorAll('section').forEach(s => s.hidden = true);
          }
        }
        
        function showMainMenu() {
          hideAllScreens();
          ui.menu.hidden = false;
          ui.roomName.textContent = "Main Menu";
          ui.chapterInfo.textContent = "Chapter 0";
          ui.clueInfo.textContent = "Clues: 0";
          ui.fearInfo.textContent = "Fear: 0";
          renderSaveSlots();
        }

        function showMenu() {
          console.log("showMenu called");
          try {
            hideAllScreens();
            ui.menu.hidden = false;
            ui.roomName.textContent = "Main Menu";
            ui.chapterInfo.textContent = "Chapter 0";
            ui.clueInfo.textContent = "Clues: 0";
            ui.fearInfo.textContent = "Fear: 0";
            renderSaveSlots();
            console.log("Menu should now be visible");
          } catch (error) {
            console.error("Error in showMenu:", error);
          }
        }

        function showGame() {
          console.log("showGame called - current room:", gameState.currentRoom);
          
          try {
            ui.menu.hidden = true;
            ui.scene.hidden = false;
            ui.choices.hidden = false;
            ui.inventory.hidden = false;
            
            const room = ROOMS[gameState.currentRoom];
            if (!room) {
              console.error("Room not found:", gameState.currentRoom);
              gameState.currentRoom = "entrance";
              room = ROOMS["entrance"];
            }
            
            setScene(room);
            renderChoices(room);
            renderInventory();
            updateStats();
            
            if (gameState.lastDialogue && !gameState.flags.troll_isolation) {
              showDialogue(gameState.lastDialogue.npcKey, gameState.lastDialogue.text);
            } else {
              clearDialogue();
            }
            
            console.log("showGame completed successfully");
          } catch (error) {
            console.error("Error in showGame:", error);
            alert("Error starting game: " + error.message);
          }
        }

        function renderSaveSlots() {
          ui.saveSlots.innerHTML = "";
          for (let i = 1; i <= 3; i++) {
            const slotKey = "manualSave" + i;
            const raw = localStorage.getItem(slotKey);
            const data = raw ? JSON.parse(raw) : null;
            const slot = document.createElement("div");
            slot.className = "save-slot";
            const label = document.createElement("div");
            label.innerHTML = data
              ? "Slot " + i + ": Chapter " + data.chapter + " â€¢ Clues " + countCluesFromData(data) + " â€¢ " + new Date(data.timestamp).toLocaleString()
              : "Slot " + i + ": Empty";
            const actions = document.createElement("div");
            const saveBtn = document.createElement("button");
            saveBtn.textContent = "Save";
            saveBtn.addEventListener("click", () => {
              if (confirm("Overwrite this save slot?")) {
                gameState.save(slotKey);
                renderSaveSlots();
              }
            });
            const loadBtn = document.createElement("button");
            loadBtn.textContent = "Load";
            loadBtn.disabled = !data;
            loadBtn.addEventListener("click", () => {
              gameState.load(slotKey);
              showGame();
            });
            actions.append(saveBtn, loadBtn);
            slot.append(label, actions);
            ui.saveSlots.appendChild(slot);
          }
        }

        function countCluesFromData(data) {
          let count = 0;
          if (data.flags?.examined_portrait) count++;
          if (data.flags?.records_found) count++;
          if (data.flags?.examined_cabinet) count++;
          if (data.flags?.heard_wall_sounds) count++;
          if (data.flags?.anaconda_hinted) count++;
          if (data.flags?.cabinet_code_solved) count++;
          if (data.flags?.cell_puzzle_solved) count++;
          if (data.flags?.first_door_code_solved) count++;
          return count;
        }

        function handleChoice(action) {
          if (!action) {
            console.warn("handleChoice called with empty action");
            return;
          }
          
          const room = ROOMS[gameState.currentRoom];
          if (!room) {
            console.error("Current room not found:", gameState.currentRoom);
            return;
          }
          
          let narration = null;
          let requestedEnding = false;
          
          // Add visual feedback for choice selection
          ui.sceneText.classList.add('text-updating');
          
          const afterAction = () => {
            setTimeout(() => {
              if (narration) {
                ui.sceneText.textContent = narration;
                gameState.lastNarration = narration;
                ui.sceneText.classList.remove('text-updating');
              }
              
              if (gameState.pendingEnding) {
                triggerEnding(gameState.pendingEnding);
                return;
              }
              
              const nextRoom = ROOMS[gameState.currentRoom];
              if (gameState.currentRoom !== room.id) {
                setScene(nextRoom);
                renderChoices(nextRoom);
              } else {
                renderChoices(nextRoom);
                if (!narration) {
                  ui.sceneText.classList.remove('text-updating');
                }
              }
              renderInventory();
              // Only autosave after successful completion of action
              setTimeout(() => gameState.autoSave(), 500);
            }, narration ? 200 : 50);
          };

          switch (action) {
            case "entrance_listen":
              gameState.flags.met_dwarf_and_troll = true;
              gameState.relationships.dwarf.met = true;
              gameState.relationships.troll.met = true;
              gameState.adjustTrust("dwarf", 10);
              gameState.adjustTrust("troll", 8);
              gameState.flags.agreed_to_help = true;
              showDialogue("dwarf", NPCs.dwarf.dialogue.first_meet[0]);
              sound.playEffect("whisper");
              narration = "You let their words settle. The corridor seems to exhale, and for a moment the iron gates feel less certain.";
              break;
            case "entrance_ask":
              gameState.flags.met_dwarf_and_troll = true;
              gameState.relationships.dwarf.met = true;
              gameState.relationships.troll.met = true;
              gameState.adjustTrust("dwarf", 4);
              gameState.adjustTrust("troll", 4);
              showDialogue("troll", NPCs.troll.dialogue.first_meet[0]);
              narration = "They tell you their names. The building listens as if it remembers them.";
              break;
            case "entrance_demand":
              gameState.flags.met_dwarf_and_troll = true;
              gameState.relationships.dwarf.met = true;
              gameState.relationships.troll.met = true;
              gameState.adjustTrust("dwarf", -8);
              gameState.adjustTrust("troll", -5);
              showDialogue("dwarf", "The exit isn't a door anymore. It's a mood.");
              narration = "Your voice echoes, and the corridor answers with silence.";
              sound.playEffect("door");
              break;
            case "go_hallway":
              gameState.currentRoom = "hallway_main";
              break;
            case "talk_dwarf":
              showDialogue("dwarf", getDwarfDialogue());
              narration = gameState.lastNarration;
              break;
            case "try_gates":
              narration = "The gates hold. Cold metal refuses your hands.";
              sound.playEffect("door");
              break;
            case "hall_examine":
              narration = "The doors are locked, but the wire mesh trembles like something brushed past from the inside.";
              sound.playEffect("scrape");
              break;
            case "go_office":
              if (gameState.flags.troll_sacrifice || gameState.relationships.troll.alive) {
                gameState.currentRoom = "office";
              } else {
                narration = "The administrative wing feels wrong without your companions. Something watches from the empty doorways.";
              }
              break;
            case "go_medical":
              gameState.currentRoom = "medical";
              break;
            case "hall_listen":
              narration = "The silence has texture. You hear breathing where there is no one.";
              gameState.flags.anaconda_hinted = true;
              sound.playEffect("breathing");
              break;
            case "talk_troll":
              showDialogue("troll", getTrollDialogue());
              narration = gameState.lastNarration;
              break;
            case "office_search":
              narration = "The files crumble at the edges. Most are empty. One name repeats in torn ink: 47.";
              gameState.flags.records_found = true;
              break;
            case "office_portrait":
              narration = "The director's portrait lists a birth year: 1947.";
              gameState.flags.examined_portrait = true;
              sound.playEffect("whisper");
              break;
            case "office_note":
              if (gameState.addItem("Handwritten Note")) {
                narration = "You take the note. The ink smells fresh despite its age.";
              } else {
                narration = "Your pack is full. The note waits.";
              }
              break;
            case "office_puzzle":
              createPuzzleInterface("first_door_code");
              return; // Don't continue with afterAction, modal handles it
            case "office_drawer":
              if (gameState.flags.first_door_code_solved) {
                narration = "The drawer remains open. The Subject 47 folder feels heavier each time you see it.";
              } else {
                narration = "The drawer is still locked.";
              }
              break;
            case "medical_cabinet":
              if (!gameState.flags.examined_cabinet) {
                narration = "The cabinet is locked by a simple keypad. Numbers are worn: 7, 3, 9.";
                gameState.flags.examined_cabinet = true;
              } else if (!gameState.flags.cabinet_code_solved) {
                narration = "The cabinet keypad still waits for the correct code.";
              } else {
                narration = "The cabinet stands open, its contents already claimed.";
              }
              break;
            case "medical_chart":
              narration = "FEAR. COMPLIANCE. ISOLATION. ACCEPTANCE. DISSOLUTION. The words feel like steps down a stairwell.";
              gameState.fear += 5;
              PsychologicalEffects.applyFlicker(ui.overlay);
              break;
            case "go_cell":
              if (!gameState.flags.cabinet_code_solved && !gameState.flags.examined_cabinet) {
                narration = "The secured ward door is sealed. You need to examine the medical ward first.";
              } else if (!gameState.flags.cabinet_code_solved) {
                createPuzzleInterface("cabinet_code");
                return; // Don't continue with afterAction, modal handles it
              } else {
                gameState.currentRoom = "cell";
              }
              break;
            case "go_basement":
              if (gameState.flags.cell_puzzle_solved) {
                gameState.currentRoom = "basement";
                // Chapter 3 begins when entering basement
                if (gameState.chapter < 3) {
                  gameState.chapter = 3;
                }
              } else {
                narration = "The hidden passage remains sealed. You need to solve the cell puzzle first.";
              }
              break;
            case "cell_read":
              if (!gameState.flags.cell_puzzle_solved) {
                const answer = prompt("The scratches form a word. Enter it:", "");
                if (answer) {
                  narration = attemptPuzzle("cell_puzzle", answer.trim().toUpperCase());
                  if (gameState.flags.cell_puzzle_solved) {
                    gameState.currentRoom = "cell";
                    gameState.chapter = 3;
                    gameState.flags.white_skeleton_seen = true;
                    sound.playEffect("door");
                  }
                }
              } else {
                narration = "The scratches have already revealed their secret. A hidden passage waits.";
              }
              break;
            case "cell_search":
              if (!gameState.flags.heard_wall_sounds) {
                narration = "You press an ear to the wall. A slow scrape follows your breath.";
                gameState.flags.heard_wall_sounds = true;
                sound.playEffect("scrape");
              } else {
                narration = "The walls remember your touch. The scraping responds.";
              }
              break;
            case "cell_listen":
              narration = "Wet breathing answers you from the concrete.";
              sound.playEffect("breathing");
              break;
            case "basement_run":
              narration = "You run. The Troll stays to hold the weight of the door.";
              triggerTrollSacrifice();
              gameState.flags.anaconda_weakening = true;
              // Force transition to alone-in-hallway phase
              gameState.currentRoom = "hallway_main";
              gameState.flags.troll_isolation = true;
              break;
            case "basement_hide":
              narration = "You crouch behind pipes. The Dwarf flinches at your silence.";
              gameState.adjustTrust("dwarf", -10);
              gameState.adjustTrust("troll", -8);
              sound.playEffect("heartbeat");
              break;
            case "basement_ask":
              narration = "The Troll speaks without looking back: \"It remembers us. It is not angry. It is hungry.\"";
              gameState.adjustTrust("troll", 5);
              break;
            case "basement_hold":
              narration = "You stand your ground. The scraping shifts away, uncertain.";
              gameState.adjustTrust("troll", 8);
              gameState.adjustTrust("dwarf", 6);
              gameState.flags.anaconda_weakening = true;
              PsychologicalEffects.applyGlitch(ui.overlay);
              break;
            case "basement_escape":
              narration = "You move toward the exit, the gates trembling as if the building is deciding.";
              requestedEnding = true;
              break;
            case "basement_stay":
              narration = "You stop. The corridor hums with recognition. Some doors open by closing.";
              gameState.flags.chose_to_stay = true;
              requestedEnding = true;
              break;
            case "basement_move":
              narration = "You step carefully through mist and memory. The exit breathes somewhere ahead.";
              gameState.flags.anaconda_weakening = true;
              break;
            case "basement_weaker":
              narration = "The scraping grows thin, like it is being pulled away from the walls.";
              gameState.flags.anaconda_weakening = true;
              break;
            case "basement_dwarf":
              if (!gameState.relationships.troll.alive) {
                narration = "You call out softly. The Dwarf's voice responds from the mist: 'I'm here. We're going to be okay.'";
                gameState.adjustTrust("dwarf", 8);
                showDialogue("dwarf", "The Troll saved us both. We have to keep moving.");
              } else {
                narration = "The Dwarf is right beside you, as always.";
              }
              break;
            default:
              console.warn("Unknown action:", action);
              narration = "Nothing happens. The building watches silently.";
              break;
          }

          if (action === "medical_cabinet") {
            const code = prompt("Enter the cabinet code (3 digits):", "");
            if (code) {
              narration = attemptPuzzle("cabinet_code", code.trim());
            }
          }

          if (action === "cell_read") {
            const answer = prompt("The scratches form a word. Enter it:", "");
            if (answer) {
              narration = attemptPuzzle("cell_puzzle", answer.trim().toUpperCase());
              if (gameState.flags.cell_puzzle_solved) {
                gameState.currentRoom = "basement";
                gameState.chapter = 3;
                gameState.flags.white_skeleton_seen = true;
                sound.playEffect("door");
              }
            }
          }

          if (action === "go_cell" && gameState.flags.cell_puzzle_solved) {
            gameState.currentRoom = "basement";
          }

          if (gameState.currentRoom === "basement") {
            gameState.chapter = 3;
          }

          // Only change background music if we're switching contexts significantly
          const currentBg = gameState.currentRoom === "basement" ? 
            "assets/audio/background/suddenBackground.mp3" :
            "assets/audio/background/mainbackground.mp3";
          
          if (!sound.currentBg || (sound.currentBg !== currentBg && gameState.currentRoom !== room.id)) {
            sound.playBackground(currentBg);
            sound.currentBg = currentBg;
          }

          const endingTriggered = checkEndings(requestedEnding);
          if (requestedEnding && !endingTriggered) {
            narration = "The door refuses. Something is missing.";
          }
          afterAction();
        }

        function attemptPuzzle(id, answer) {
          const puzzle = PUZZLES[id];
          let isCorrect = false;
          
          if (puzzle.type === 'sequence_items') {
            // Compare arrays
            isCorrect = Array.isArray(answer) && 
                       answer.length === puzzle.solution.length &&
                       answer.every((item, index) => item === puzzle.solution[index]);
          } else {
            // Compare strings
            isCorrect = String(answer).toUpperCase() === String(puzzle.solution).toUpperCase();
          }
          
          if (isCorrect) {
            sound.playEffect("door");
            return puzzle.consequence(gameState);
          }
          sound.playEffect("scare");
          return "The attempt fails. Something resists your efforts.";
        }

        function getDwarfDialogue() {
          const trust = gameState.relationships.dwarf.trust;
          const dialogues = NPCs.dwarf.dialogue;
          
          if (gameState.flags.troll_sacrifice) {
            return getRandomDialogue(dialogues.troll_death);
          }
          if (gameState.flags.heard_wall_sounds) {
            return getRandomDialogue(dialogues.wall_sounds);
          }
          
          // Mix trust-based and general dialogue
          const generalDialogue = getRandomDialogue(dialogues.general);
          const trustDialogue = trust > 40 ? dialogues.trust_check.high :
                               trust >= 0 ? dialogues.trust_check.mid :
                               dialogues.trust_check.low;
          
          return Math.random() > 0.6 ? generalDialogue : trustDialogue;
        }

        function getTrollDialogue() {
          const trust = gameState.relationships.troll.trust;
          const dialogues = NPCs.troll.dialogue;
          
          const generalDialogue = getRandomDialogue(dialogues.general);
          const trustDialogue = trust > 40 ? dialogues.trust_check.high :
                               trust >= 0 ? dialogues.trust_check.mid :
                               dialogues.trust_check.low;
          
          return Math.random() > 0.5 ? generalDialogue : trustDialogue;
        }

        function createPuzzleInterface(puzzleId) {
          const puzzle = PUZZLES[puzzleId];
          const modal = ui.puzzleModal;
          const title = document.getElementById('puzzle-title');
          const content = document.getElementById('puzzle-content');
          const hints = document.getElementById('puzzle-hints');
          const controls = document.getElementById('puzzle-controls');
          
          title.textContent = `${puzzle.type.toUpperCase()} PUZZLE`;
          
          // Create puzzle interface based on type
          if (puzzle.type === 'sequence' || puzzle.type === 'combination' || puzzle.type === 'word') {
            content.innerHTML = `
              <p style="margin-bottom: 16px; color: var(--parchment);">${puzzle.clue}</p>
              <input type="text" class="puzzle-input" id="puzzle-answer" 
                     placeholder="Enter ${puzzle.type === 'word' ? 'word' : 'code'}..." maxlength="10">
            `;
          } else if (puzzle.type === 'sequence_items') {
            content.innerHTML = `
              <p style="margin-bottom: 16px; color: var(--parchment);">${puzzle.clue}</p>
              <div id="item-sequence" style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
                ${gameState.inventory.map(item => `
                  <button class="item-btn" data-item="${item.replace(/\s+/g, '_').toUpperCase()}">
                    ${item}
                  </button>
                `).join('')}
              </div>
              <div id="sequence-display" style="margin-top: 16px; min-height: 40px; border: 2px dashed var(--gold); border-radius: 8px; padding: 12px; text-align: center; color: var(--gold);">Select items in sequence...</div>
            `;
          }
          
          // Create hint system
          hints.innerHTML = `
            <p style="margin-bottom: 8px; color: var(--neon-blue);">Need help?</p>
            ${puzzle.hints.map((hint, index) => `
              <button class="hint-btn" onclick="revealHint(${index})" id="hint-${index}">
                Hint ${index + 1}
              </button>
            `).join('')}
          `;
          
          // Create controls
          controls.innerHTML = `
            <button class="choice-btn" style="margin: 16px 8px 0 0;" onclick="solvePuzzle('${puzzleId}')">Solve</button>
            <button class="choice-btn" style="margin: 16px 0 0 8px;" onclick="closePuzzle()">Close</button>
          `;
          
          modal.hidden = false;
          
          // Add click outside to close
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              closePuzzle();
            }
          });
          
          // Add escape key to close
          const escapeHandler = (e) => {
            if (e.key === 'Escape') {
              closePuzzle();
              document.removeEventListener('keydown', escapeHandler);
            }
          };
          document.addEventListener('keydown', escapeHandler);
          
          // Focus on input if it exists and add enter key support
          const input = document.getElementById('puzzle-answer');
          if (input) {
            setTimeout(() => {
              input.focus();
              input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                  solvePuzzle(puzzleId);
                }
              });
            }, 100);
          }
          
          // Add event listeners for item sequence puzzle
          if (puzzle.type === 'sequence_items') {
            const sequenceState = [];
            document.querySelectorAll('.item-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                const item = btn.dataset.item;
                sequenceState.push(item);
                document.getElementById('sequence-display').textContent = sequenceState.join(' â†’ ');
                btn.disabled = true;
                btn.style.opacity = '0.5';
              });
            });
            window.currentSequence = sequenceState;
          }
        }
        
        function revealHint(index) {
          const hintBtn = document.getElementById(`hint-${index}`);
          const puzzle = Object.values(PUZZLES).find(p => p.hints);
          hintBtn.textContent = puzzle.hints[index];
          hintBtn.disabled = true;
          hintBtn.style.background = 'rgba(0,243,255,0.4)';
        }
        
        function solvePuzzle(puzzleId) {
          const puzzle = PUZZLES[puzzleId];
          let answer;
          
          if (puzzle.type === 'sequence_items') {
            answer = window.currentSequence;
          } else {
            answer = document.getElementById('puzzle-answer').value.trim().toUpperCase();
          }
          
          const result = attemptPuzzle(puzzleId, answer);
          
          // Show result with dramatic effect
          const resultDiv = document.createElement('div');
          resultDiv.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(139,0,0,0.9), rgba(0,0,0,0.9));
            border: 3px solid var(--gold); border-radius: 16px; padding: 24px;
            color: var(--parchment); text-align: center; font-size: 1.2rem;
            z-index: 10000; max-width: 80%; animation: resultFade 4s ease forwards;
          `;
          resultDiv.textContent = result;
          document.body.appendChild(resultDiv);
          
          setTimeout(() => {
            closePuzzle();
            document.body.removeChild(resultDiv);
            
            // Handle specific puzzle completions
            if (gameState.flags.cell_puzzle_solved && puzzleId === 'cell_puzzle') {
              gameState.currentRoom = "cell";
              gameState.flags.white_skeleton_seen = true;
            }
            if (gameState.flags.cabinet_code_solved && puzzleId === 'cabinet_code') {
              gameState.currentRoom = "cell";
            }
            
            // Continue game flow
            const nextRoom = ROOMS[gameState.currentRoom];
            setScene(nextRoom);
            renderChoices(nextRoom);
            renderInventory();
            updateStats();
          }, 3000);
        }
        
        function closePuzzle() {
          if (ui.puzzleModal) {
            ui.puzzleModal.hidden = true;
            // Remove any active event listeners by clearing content
            document.getElementById('puzzle-content').innerHTML = '';
            document.getElementById('puzzle-hints').innerHTML = '';
            document.getElementById('puzzle-controls').innerHTML = '';
          }
          if (window.currentSequence) {
            window.currentSequence = [];
          }
        }

        function triggerTrollSacrifice() {
          if (!gameState.relationships.troll.alive) return;
          gameState.relationships.troll.alive = false;
          gameState.flags.troll_sacrifice = true;
          gameState.adjustTrust("dwarf", 12);
          showDialogue("troll", NPCs.troll.dialogue.sacrifice[0]);
          PsychologicalEffects.applyBlood(ui.overlay);
        }

        function checkEndings(requested) {
          if (!requested) return false;
          for (const key of Object.keys(ENDINGS)) {
            const ending = ENDINGS[key];
            if (ending.condition(gameState)) {
              gameState.pendingEnding = ending;
              return true;
            }
          }
          return false;
        }

        function triggerEnding(ending) {
          gameState.currentRoom = "entrance";
          ui.sceneText.textContent = ending.text;
          ui.dialogue.hidden = true;
          ui.choices.innerHTML = "";
          ui.inventory.innerHTML = "";
          ui.choices.appendChild(createButton("Return to Menu", () => showMenu()));
        }

        function createButton(label, onClick) {
          const button = document.createElement("button");
          button.className = "choice-btn";
          button.textContent = "â†’ " + label;
          button.addEventListener("click", onClick);
          return button;
        }

        function startNewGame() {
          try {
            console.log("Starting new game...");
            gameState.apply({
              playerName: "You",
              chapter: 1,
              currentRoom: "entrance",
              inventory: [],
              fear: 0,
              npcs: {
                "Dr. Helena": { trust: 5, lastInteraction: Date.now() },
                "The Presence": { trust: 0, lastInteraction: null }
              },
              relationships: {
                dwarf: { trust: 0, alive: true, met: false },
                troll: { trust: 0, alive: true, met: false }
              },
              flags: {
                met_dwarf_and_troll: false,
                agreed_to_help: false,
                examined_portrait: false,
                records_found: false,
                examined_cabinet: false,
                heard_wall_sounds: false,
                anaconda_hinted: false,
                anaconda_weakening: false,
                troll_sacrifice: false,
                first_door_code_solved: false,
                learned_truth: false,
                cabinet_code_solved: false,
                cell_puzzle_solved: false,
                white_skeleton_seen: false,
                chose_to_stay: false
              },
              roomsVisited: {},
              fear: 0,
              audioOn: gameState.audioOn
            });

            // Use dramatic sudden background music for entire game
            try {
              if (gameState.audioOn) {
                const audio = new Audio("assets/audio/background/suddenBackground.mp3");
                audio.loop = true;
                audio.volume = 0.3;
                audio.play().catch(e => console.warn("Audio autoplay blocked:", e));
              }
            } catch (error) {
              console.warn("Background music failed:", error);
            }

            showGame();
          } catch (e) {
            console.error("New Game Error:", e);
            alert("Failed to start new game: " + e.message);
          }
        }

        function autoSaveLoop() {
          setInterval(() => gameState.autoSave(), 30000);
          window.addEventListener("beforeunload", () => gameState.autoSave());
        }

        function init() {
          console.log("Initializing Game Engine");
          
          // Check if UI elements exist
          if (!ui.newGame) {
            console.error("New Game button not found");
            return;
          }
          if (!ui.continueGame) {
            console.error("Continue Game button not found");
            return;
          }
          if (!ui.toggleAudio) {
            console.error("Toggle Audio button not found");
            return;
          }

          ui.newGame.addEventListener("click", () => {
            console.log("UI: New Game button clicked");
            startNewGame();
          });

          ui.continueGame.addEventListener("click", () => {
            console.log("UI: Continue button clicked");
            try {
              if (gameState.load("autoSave")) {
                showGame();
              } else {
                startNewGame();
              }
            } catch (e) {
              console.warn("Save corrupted, starting new game:", e);
              startNewGame();
            }
          });

          ui.toggleAudio.addEventListener("click", () => {
            gameState.audioOn = !gameState.audioOn;
            ui.toggleAudio.textContent = "Audio: " + (gameState.audioOn ? "On" : "Off");
          });

          const hasSave = (() => {
            try {
              return gameState.load("autoSave");
            } catch (e) {
              return false;
            }
          })();

          ui.continueGame.disabled = !hasSave;

          // Ensure menu is visible on startup
          showMenu();
          console.log("Game initialization completed");
        }

        function getRandomDialogue(dialogueArray) {
          return dialogueArray[Math.floor(Math.random() * dialogueArray.length)];
        }

        try {
          init();
        } catch (err) {
          console.error("Init error", err);
          const errorBox = document.createElement("div");
          errorBox.style.cssText = "position:fixed; top:0; left:0; right:0; padding:20px; background:#800; color:#fff; z-index:9999; font-family:monospace;";
          errorBox.innerHTML = "<strong>Init Error:</strong> " + err.message;
          document.body.appendChild(errorBox);
        }
  </script>
</body>
</html>
